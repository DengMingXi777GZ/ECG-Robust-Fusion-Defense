# ECG 对抗攻防系统 - 代码清单

**文档版本**: v1.0  
**更新时间**: 2026-02-08  
**总文件数**: 30+ 个 Python 文件  
**总代码行数**: 4,500+ 行  

---

## 目录

1. [攻击层 (Attacks)](#一攻击层-attacks)
2. [防御层 (Defense)](#二防御层-defense)
3. [模型定义 (Models)](#三模型定义-models)
4. [特征工程 (Features)](#四特征工程-features)
5. [数据加载 (Data)](#五数据加载-data)
6. [评估分析 (Evaluation)](#六评估分析-evaluation)
7. [可视化 (Visualization)](#七可视化-visualization)
8. [训练脚本](#八训练脚本)

---

## 一、攻击层 (Attacks)

### 1.1 base_attack.py
**路径**: `attacks/base_attack.py`  
**作用**: 攻击算法的抽象基类，定义统一接口

**类定义**:
```python
class BaseAttack(ABC)
```

**关键方法**:
- `__init__(model, device, eps)`: 初始化攻击器
- `generate(x, y, targeted)`: 抽象方法，生成对抗样本
- `clip(x_adv, x_orig)`: 投影回 epsilon 球和 [0,1] 范围

**被继承**: FGSM, PGD, SAP

---

### 1.2 fgsm.py
**路径**: `attacks/fgsm.py`  
**作用**: FGSM (Fast Gradient Sign Method) 快速梯度符号攻击

**公式**: 
```
x_adv = x + ε · sign(∇_x L(f(x), y))
```

**类定义**:
```python
class FGSM(BaseAttack)
```

**关键方法**:
- `generate(x, y, targeted=False)`: 单步生成对抗样本
  - 输入: `x` [B,1,187], `y` [B]
  - 输出: `x_adv` [B,1,187]

**特点**:
- 速度快，单步完成
- 攻击强度较弱
- 支持 targeted 模式

---

### 1.3 pgd.py ⭐
**路径**: `attacks/pgd.py`  
**作用**: PGD (Projected Gradient Descent) 投影梯度下降攻击，标准白盒攻击

**公式**:
```
x_adv = x + random_noise(-ε, ε)
for t in range(num_steps):
    grad = compute_gradient(loss(f(x_adv), y), x_adv)
    x_adv = x_adv + α · sign(grad)
    x_adv = clip(x_adv, x, ε)
```

**类定义**:
```python
class PGD(BaseAttack)
```

**参数**:
- `eps`: 扰动上限 (默认 0.05)
- `num_steps`: 迭代步数 (默认 20)
- `alpha`: 步长 (默认 eps/4)
- `random_start`: 是否随机初始化 (默认 True)

**关键方法**:
- `generate(x, y)`: 迭代生成对抗样本
  - 输入: `x` [B,1,187], `y` [B]
  - 输出: `x_adv` [B,1,187]

**使用场景**:
- 标准对抗训练
- 鲁棒性评估
- 对抗样本数据集生成

---

### 1.4 sap.py ⭐⭐
**路径**: `attacks/sap.py`  
**作用**: SAP (Smooth Adversarial Perturbation) 平滑对抗扰动攻击，核心创新

**论文**: Han et al., "Deep learning models for electrocardiograms are susceptible to adversarial attack", Nature Medicine 2020

**核心思想**: 
- 传统 PGD 直接在输入空间优化，产生高频噪声
- SAP 在平滑扰动参数空间优化，产生生理更可信的扰动

**类定义**:
```python
class SAP(BaseAttack)
```

**关键属性**:
```python
self.kernel_sizes = [5, 7, 11, 15, 19]  # 高斯核尺寸
self.sigmas = [1.0, 3.0, 5.0, 7.0, 10.0]  # 高斯核标准差
self.kernels = [...]  # 预计算的多尺度高斯核
```

**关键方法**:
- `_gaussian_kernel(size, sigma)`: 生成高斯卷积核
- `generate(x, y, num_steps=40)`: 
  1. 初始化可学习扰动 theta
  2. PGD 初始化加速收敛
  3. 多尺度平滑: `perturb_smooth = mean(conv(theta, kernel_i))`
  4. 使用 Adam 优化 theta
  5. 约束 theta 在 [-eps, eps] 范围内

**输入**: `x` [B,1,187], `y` [B]  
**输出**: `x_adv` [B,1,187] (平滑扰动)

**特点**:
- 平滑度比 PGD 低 85%
- 频谱高频成分显著减少
- 人眼难以区分

---

## 二、防御层 (Defense)

### 2.1 adv_trainer.py
**路径**: `defense/adv_trainer.py`  
**作用**: 对抗训练数据集生成器，动态生成对抗样本

**类定义**:
```python
class AdversarialDataset(Dataset)
```

**关键方法**:
- `__init__(clean_dataset, model, attack_method, eps, steps, alpha)`
- `__getitem__(idx)`: 动态生成对抗样本
  - 返回: `(x_clean, x_adv, y)`

**特点**:
- 节省内存，不预存对抗样本
- 每次迭代生成新的噪声，防止过拟合
- 支持 PGD 和 SAP 两种攻击

---

### 2.2 nsr_loss.py ⭐
**路径**: `defense/nsr_loss.py`  
**作用**: NSR (Noise-to-Signal Ratio) 正则化损失函数

**论文**: Ma & Liang, "Explainable Deep Learning for Efficient Adversarial Defense", 2022

**公式**:
```
L_NSR = MSE_loss + Margin_loss + β · NSR_regularization

其中:
- MSE_loss = (z_y - 1)² + Σ_{i≠y}(z_i - 0)²
- Margin_loss = Σ_{i≠y} max(0, 1 - z_y + z_i)
- NSR = log(R + 1), R = (||w_y||₁ · ε) / |z_y|
```

**类定义**:
```python
class NSRLoss(nn.Module)
```

**参数**:
- `beta`: 正则化系数 (默认 0.4)
- `eps`: 扰动预算 (默认 0.05)

**关键方法**:
- `forward(model, x, y, output)`:
  1. 计算 MSE Loss (One-hot 目标)
  2. 计算 Margin Loss
  3. 计算 NSR Regularization:
     - 对每个样本计算 `||w_y||_1` (输出对输入梯度的 L1 范数)
     - 计算 R = (||w_y||_1 · ε) / |z_y|
     - NSR = β · mean(log(R + 1))
  4. 仅对正确分类样本应用 NSR

**使用技巧**:
- 延迟启动 (前 10 epoch beta=0)
- 防止初期梯度爆炸

---

### 2.3 train_standard_at.py
**路径**: `defense/train_standard_at.py`  
**作用**: 标准对抗训练 (Madry's Adversarial Training)

**算法**:
```python
for x_clean, y in loader:
    # 1. 生成对抗样本
    x_adv = PGD(model, eps=0.05, steps=10).generate(x_clean, y)
    
    # 2. 混合数据 (各50%)
    x_mixed = torch.cat([x_clean, x_adv], dim=0)
    y_mixed = torch.cat([y, y], dim=0)
    
    # 3. 标准训练
    loss = CrossEntropy(model(x_mixed), y_mixed)
```

**输出**: `checkpoints/adv_standard_at.pth`  
**性能**: Clean=96.04%, PGD-20=92.08%, ACC_robust=0.94

---

### 2.4 train_nsr.py
**路径**: `defense/train_nsr.py`  
**作用**: NSR 正则化训练

**特点**:
- 使用 NSRLoss 替代 CrossEntropy
- 延迟启动 NSR (前 10 epoch)
- Beta 超参数搜索

**输出**: `checkpoints/nsr_beta0.4.pth`  
**性能**: Clean=97.27%, PGD-20=80.95%, ACC_robust=0.89

---

### 2.5 train_at_nsr.py ⭐
**路径**: `defense/train_at_nsr.py`  
**作用**: AT+NSR 联合训练 (最佳防御方法)

**算法**:
```python
# 1. 生成对抗样本 (AT部分)
x_adv = PGD(model, eps=0.05, steps=10).generate(x_clean, y)
x_mixed = torch.cat([x_clean, x_adv], dim=0)

# 2. 使用 NSR Loss 训练
loss, loss_dict = nsr_criterion(model, x_mixed, y_mixed, output)
```

**输出**: `checkpoints/at_nsr.pth`  
**性能**: Clean=95.28%, PGD-20=91.53%, ACC_robust=0.94

---

## 三、模型定义 (Models)

### 3.1 ecg_cnn.py
**路径**: `models/ecg_cnn.py`  
**作用**: 1D-CNN ECG 分类模型 (Layer 1 & 2 基础模型)

**架构参考**: Ma & Liang 2022

**类定义**:
```python
class ECG_CNN(nn.Module)
```

**网络结构**:
```
Input [B, 1, 187]
  ├── Conv1d(1→16, k=7) → BN → ReLU → MaxPool → [B, 16, 93]
  ├── Conv1d(16→32, k=5) → BN → ReLU → MaxPool → [B, 32, 46]
  ├── Conv1d(32→64, k=3) → BN → ReLU → MaxPool → [B, 64, 23]
  ├── Conv1d(64→128, k=3) → BN → ReLU → MaxPool → [B, 128, 11]
  ├── Global Average Pooling → [B, 128]
  ├── FC(128→64) → ReLU → Dropout(0.3)
  └── FC(64→5) → Logits
```

**参数量**: 42,501 (42.5K)

**关键方法**:
- `forward(x)`: 前向传播
- `count_parameters()`: 统计参数量
- `_initialize_weights()`: Kaiming 初始化

---

### 3.2 fusion_model.py ⭐⭐
**路径**: `models/fusion_model.py`  
**作用**: 双分支融合网络 (Layer 3 核心)

**类定义**:
```python
class DualBranchECG(nn.Module)      # 融合模型
class DeepOnlyModel(nn.Module)       # 仅 Deep Branch (对比)
class HandcraftedOnlyModel(nn.Module) # 仅 Handcrafted Branch (对比)
```

**架构**:
```
Input: x_signal [B, 1, 187], x_handcrafted [B, 12]
         │
         ├─→ Deep Branch (CNN) ──────────────────────┐
         │    加载 at_nsr.pth 预训练权重             │
         │    Conv Blocks → GlobalPool → FC(128→128) │
         │    输出: deep_feat [B, 128]               │
         │                                             │
         └─→ Handcrafted Branch (MLP) ───────────────┤
              FC(12→32) → ReLU → Dropout(0.3)        │
              FC(32→16) → ReLU                       │
              输出: hc_feat [B, 16]                  │
                                                        │
         Fusion Layer ←───────────────────────────────┘
         concat([deep_feat, hc_feat]) → [B, 144]
         FC(144→64) → ReLU → Dropout(0.3)
         FC(64→5) → Logits
```

**参数量**: 61,173 (61.2K)
- Deep Branch: 50,624 (82.8%)
- Handcrafted Branch: 944 (1.5%)
- Fusion Layer: 9,605 (15.7%)

**关键方法**:
- `__init__(num_classes=5, pretrained_path, freeze_deep_branch)`
- `forward(x_signal, x_handcrafted)`: 返回 (output, deep_feat, hc_feat)
- `freeze_deep_branch()`: 冻结 Deep Branch
- `unfreeze_deep_branch()`: 解冻 Deep Branch

**输出**:
- `output`: [B, 5] 分类 logits
- `deep_feat`: [B, 128] 深度特征
- `hc_feat`: [B, 16] 手工特征

---

### 3.3 adversarial_detector.py ⭐⭐
**路径**: `models/adversarial_detector.py`  
**作用**: 对抗样本检测器 (Layer 3 核心)

**核心思想**:
- 正常样本: Deep CNN 和手工特征预测一致
- 对抗样本: Deep CNN 被骗，手工特征仍正确，产生分歧

**类定义**:
```python
class AdversarialDetector(nn.Module)
```

**架构**:
```
Input: x_signal [B, 1, 187], x_handcrafted [B, 12]
         │
         └─→ Fusion Model (冻结参数)
              ├── deep_feat [B, 128] ─→ aux_deep_classifier ─→ deep_logits [B, 5]
              └── hc_feat [B, 16] ───→ aux_hc_classifier ────→ hc_logits [B, 5]
         
         disagreement = |deep_logits - hc_logits| [B, 5]
         
         concat([deep_logits, hc_logits, disagreement]) → [B, 15]
         FC(15→32) → ReLU
         FC(32→1) → Sigmoid
         
         Output: is_adversarial [B, 1] (0=Clean, 1=Adversarial)
```

**参数量**: 1,275 (可训练)

**关键方法**:
- `__init__(fusion_model)`: 
  - 冻结融合模型
  - 初始化两个辅助分类器
  - 初始化检测头
- `forward(x_signal, x_handcrafted)`:
  - 返回 (detection_prob, deep_logits, hc_logits, disagreement)
- `predict(x_signal, x_handcrafted, threshold=0.5)`:
  - 返回 (is_adversarial, detection_prob)
- `count_trainable_parameters()`: 统计可训练参数

**辅助函数**:
- `prepare_detection_data()`: 准备平衡数据集 (Clean:Adv=1:1)
- `train_detector()`: 训练检测器 (BCE Loss + Adam)
- `evaluate_detector()`: 评估检测器 (AUC-ROC, Accuracy, Precision, Recall)
- `main()`: 主训练流程

**输出**: `checkpoints/detector_best.pth`  
**性能**: AUC-ROC=0.9217, Accuracy=0.8042, Precision=0.8814, Recall=0.6968

---

## 四、特征工程 (Features)

### 4.1 ecg_features.py ⭐⭐
**路径**: `features/ecg_features.py`  
**作用**: ECG 生理特征提取器 (Layer 3 核心)

**类定义**:
```python
class ECGFeatureExtractor
```

**提取特征** (12维):
| 类别 | 特征 | 维度 | 生理意义 |
|------|------|------|----------|
| 心率变异性 | RR_mean, RR_std, RR_max, RR_min | 4 | 心律不齐检测 |
| 波形形态 | QRS_width, PR_interval, QT_interval | 3 | 传导阻滞 |
| 频域特征 | LF_power, HF_power, LF_HF_ratio | 3 | 自主神经平衡 |
| 统计特征 | Signal_skewness, Signal_kurtosis | 2 | 信号分布特性 |

**关键方法**:
- `__init__(sampling_rate=360)`
- `extract(signal)`: 
  - 输入: `signal` [187] 单条 ECG
  - 输出: `features` [12] 12维特征
  - 步骤:
    1. R峰检测 (梯度+阈值法)
    2. RR间期计算
    3. QRS宽度估计
    4. PR/QT间期估计
    5. 频域特征计算 (Welch方法)
    6. 统计特征计算
- `extract_batch(signals, verbose=True)`: 批量提取
  - 输入: `signals` [N, 187]
  - 输出: `features` [N, 12]

**使用示例**:
```python
extractor = ECGFeatureExtractor(sampling_rate=360)
features = extractor.extract(signal)  # [12]
```

---

### 4.2 extract_mitbih_features.py
**路径**: `features/extract_mitbih_features.py`  
**作用**: 提取 MIT-BIH 测试集的手工特征

**输入**: `data/mitbih_test.csv`  
**输出**: `data/handcrafted_features_test.npy` (21892, 12)

---

### 4.3 extract_train_features.py
**路径**: `features/extract_train_features.py`  
**作用**: 提取 MIT-BIH 训练集的手工特征

**输入**: `data/mitbih_train.csv`  
**输出**: `data/handcrafted_features_train.npy` (87554, 12)

---

## 五、数据加载 (Data)

### 5.1 mitbih_loader.py
**路径**: `data/mitbih_loader.py`  
**作用**: MIT-BIH 数据集基础加载器

**关键函数**:
- `load_mitbih_data()`: 加载原始 CSV 文件
- `MITBIHDataset(Dataset)`: PyTorch Dataset 类
  - 支持 Min-Max 归一化
  - 支持数据增强
- `get_data_loaders(batch_size, num_workers)`: 返回 DataLoader

**输出**: `(signal, label)` 对

---

### 5.2 fusion_dataset.py ⭐
**路径**: `data/fusion_dataset.py`  
**作用**: 融合模型数据集 (返回 signal + handcrafted + label)

**类定义**:
```python
class FusionDataset(Dataset)              # 基础融合数据集
class FusionDatasetWithAdversarial(Dataset)  # 包含对抗样本 (用于检测器)
```

**关键方法**:
- `__init__(signals, labels, handcrafted_features, normalize=True)`
  - 标准化: Z-score (均值为0，方差为1)
- `__getitem__(idx)`: 返回 `(signal, handcrafted, label)`

**辅助函数**:
- `load_mitbih_data_for_fusion()`: 加载融合数据
- `load_adversarial_for_fusion()`: 加载对抗样本及特征

**输出**:
- `signal`: [1, 187] torch.Tensor
- `handcrafted`: [12] torch.Tensor
- `label`: scalar torch.LongTensor

---

## 六、评估分析 (Evaluation)

### 6.1 attack_metrics.py
**路径**: `evaluation/attack_metrics.py`  
**作用**: 攻击效果评估指标计算

**关键函数**:
- `attack_success_rate(model, x_adv, y_true)`: ASR 攻击成功率
- `perturbation_l2(x_adv, x_orig)`: L2 扰动大小
- `perturbation_linf(x_adv, x_orig)`: Linf 扰动大小
- `signal_noise_ratio(x_orig, delta)`: SNR 信噪比
- `smoothness(delta)`: 扰动平滑度 (variance of diff)

---

### 6.2 defense_eval.py
**路径**: `evaluation/defense_eval.py`  
**作用**: 防御效果评估框架

**关键函数**:
- `evaluate_robustness(model, test_loader, eps)`: 
  - 评估 Clean, FGSM, PGD-20, PGD-100, SAP 准确率
- `compare_models()`: 对比所有防御模型
- `generate_comparison_table(results)`: 生成 CSV 表格

**输出**:
- `results/defense_evaluation.json`
- `results/defense_comparison.csv`

---

### 6.3 fusion_eval.py ⭐
**路径**: `evaluation/fusion_eval.py`  
**作用**: 融合模型评估 (生成论文 Table 3)

**关键类**:
```python
class ModelWrapper(nn.Module)              # 使融合模型兼容攻击接口
class FusionWithDetector(nn.Module)        # 带检测器的融合模型
```

**评估模型**:
1. Clean Model (Layer 1)
2. Standard AT (Layer 2)
3. AT+NSR (Layer 2)
4. Fusion (Layer 3)
5. Fusion+Detection (Layer 3)

**关键函数**:
- `evaluate_all_models(test_loader, handcrafted_features, eps, device)`
- `evaluate_model(model, loader, device, model_name)`
- `evaluate_robustness(model, loader, eps, device, model_name)`

**输出**:
- `results/model_comparison.csv`
- `results/model_comparison.json`

---

### 6.4 feature_robustness.py ⭐
**路径**: `analysis/feature_robustness.py`  
**作用**: 手工特征鲁棒性分析

**关键函数**:
- `extract_features_batch(X, extractor)`: 批量提取特征
- `compute_feature_drift(X_clean, X_adv)`: 计算特征漂移
- `compute_feature_correlation(X_clean, X_adv)`: 计算相关系数
- `analyze_robustness()`: 主分析函数

**分析内容**:
- Clean vs PGD 特征漂移
- Clean vs SAP 特征漂移
- 找出最稳定的特征 (drift < threshold)

**输出**:
- `results/feature_robustness_analysis.json`
- `results/feature_robustness_analysis.png` (可视化)

---

## 七、可视化 (Visualization)

### 7.1 feature_space.py ⭐
**路径**: `visualization/feature_space.py`  
**作用**: 特征空间可视化

**关键函数**:
- `load_model_and_data()`: 加载模型和数据
- `extract_features_from_model()`: 提取 Deep 和 Handcrafted 特征
- `visualize_tsne(features, labels, title, save_path)`: 
  - t-SNE 降维可视化
  - Clean (蓝色), PGD (红色), SAP (绿色)
- `compute_permutation_importance()`: 计算特征重要性
- `plot_feature_importance()`: 绘制重要性柱状图

**输出图表**:
- `results/tsne_deep_features.png`: Deep 特征 t-SNE
- `results/tsne_handcrafted_features.png`: 手工特征 t-SNE
- `results/feature_importance.png`: 特征重要性排序

---

## 八、训练脚本

### 8.1 train_baseline.py
**路径**: `train_baseline.py`  
**作用**: 训练基线模型 (Layer 1)

**输出**: `checkpoints/clean_model.pth`  
**性能**: Clean Accuracy = 93.43%

---

### 8.2 generate_adversarial_dataset.py
**路径**: `generate_adversarial_dataset.py`  
**作用**: 生成对抗样本数据集

**输入**: `checkpoints/clean_model.pth`  
**输出**:
- `data/adversarial/eps005/test_fgsm.pt`
- `data/adversarial/eps005/test_pgd.pt`
- `data/adversarial/eps005/test_sap.pt`

**参数**:
- `--eps`: 扰动上限 (默认 0.05)
- `--pgd_steps`: PGD 迭代步数 (默认 40)
- `--sap_steps`: SAP 迭代步数 (默认 40)

---

### 8.3 train_fusion.py ⭐⭐
**路径**: `train_fusion.py`  
**作用**: 融合模型训练脚本 (Layer 3 核心)

**两阶段训练策略**:

**阶段 1** (10 epochs, lr=1e-3):
```python
# 冻结 Deep Branch
for param in model.deep_branch.parameters():
    param.requires_grad = False
# 只训练 Handcrafted Branch 和 Fusion Layer
```

**阶段 2** (5 epochs, lr=1e-5):
```python
# 解冻 Deep Branch
model.unfreeze_deep_branch()
# 联合微调
```

**关键函数**:
- `train_epoch(model, loader, criterion, optimizer, device)`
- `evaluate_clean(model, loader, device)`
- `evaluate_robustness(model, loader, device, eps)`
- `train_fusion_model(args)`

**命令行参数**:
```bash
python train_fusion.py \
    --pretrained checkpoints/at_nsr.pth \
    --epochs_stage1 10 \
    --lr_stage1 1e-3 \
    --epochs_stage2 5 \
    --lr_stage2 1e-5 \
    --batch_size 128 \
    --eps 0.01
```

**输出**:
- `checkpoints/fusion_best.pth`
- `results/fusion_training_history.json`
- `results/fusion_evaluation_results.json`

**验收标准**:
- Clean Accuracy ≥ 90% ✅ (实际 95.22%)
- PGD-20 ≥ 85% ✅ (实际 93.20%)
- SAP ≥ 90% ✅ (实际 94.60%)

---

### 8.4 run_layer2_defense.py
**路径**: `run_layer2_defense.py`  
**作用**: 一键运行 Layer 2 所有防御训练

**执行流程**:
1. 训练 Standard AT
2. 训练 NSR (β=0.4)
3. 训练 AT+NSR
4. 对比评估

---

## 九、辅助脚本

### 9.1 download_data.py
**路径**: `download_data.py`  
**作用**: 下载 MIT-BIH 数据集

---

### 9.2 test_attacks.py
**路径**: `test_attacks.py`  
**作用**: 测试攻击算法

---

### 9.3 debug_attack.py / debug_gradient.py
**路径**: `debug_attack.py`, `debug_gradient.py`  
**作用**: 调试攻击算法和梯度计算

---

## 十、文件依赖关系图

```
train_fusion.py
    ├── models/fusion_model.py
    │       └── models/ecg_cnn.py
    ├── data/fusion_dataset.py
    │       └── features/ecg_features.py
    ├── attacks/pgd.py
    │       └── attacks/base_attack.py
    └── attacks/sap.py
            └── attacks/base_attack.py

models/adversarial_detector.py
    ├── models/fusion_model.py
    └── data/fusion_dataset.py

evaluation/fusion_eval.py
    ├── models/fusion_model.py
    ├── models/adversarial_detector.py
    ├── attacks/pgd.py
    └── attacks/sap.py
```

---

## 十一、快速查找表

### 按功能查找

| 功能 | 文件 |
|------|------|
| 训练基线模型 | `train_baseline.py` |
| 生成对抗样本 | `generate_adversarial_dataset.py` |
| 训练防御模型 | `defense/train_at_nsr.py` |
| 训练融合模型 | `train_fusion.py` |
| 训练检测器 | `models/adversarial_detector.py` (main) |
| 评估防御效果 | `evaluation/defense_eval.py` |
| 评估融合效果 | `evaluation/fusion_eval.py` |
| 特征提取 | `features/ecg_features.py` |
| 特征分析 | `analysis/feature_robustness.py` |
| 可视化 | `visualization/feature_space.py` |

### 按论文章节查找

| 论文章节 | 相关文件 |
|----------|----------|
| 第 3 章 攻击方法 | `attacks/fgsm.py`, `attacks/pgd.py`, `attacks/sap.py` |
| 第 4 章 防御方法 | `defense/train_standard_at.py`, `defense/train_nsr.py`, `defense/nsr_loss.py` |
| 第 5 章 特征融合 | `models/fusion_model.py`, `models/adversarial_detector.py`, `features/ecg_features.py` |
| 第 6 章 实验分析 | `evaluation/defense_eval.py`, `evaluation/fusion_eval.py`, `analysis/feature_robustness.py` |

---

**文档结束**
